#!/usr/bin/env python


'''
Connect to an energy monitoring device as those designed by Joseph
King of Rhizome Systems.  (These devices speak in TCP/IP and can
accept only one connection at a time.  They emit 45 bytes of data
about once every 10 seconds.)  Interpret the data, process it for
easier retrieval later (storage is cheap), and wait for the next
45-byte message.  (Loop endlessly unless interrupted.)  Called with
two arguments:  The sensor ID (as represented in the PostgreSQL DB)
and a command (start, stop, restart).  Daemonize on initialization.
'''


import sys
sys.path.append('/var/local/energy/lib')
import socket, psycopg2, datetime, os.path, time, atexit, signal
from binascii import hexlify
from daemon import Daemon
from energyconfig import *
from logging import error, info, debug, basicConfig


class EnergyMonDaemon(Daemon):
    '''
    Subclass of a daemonizing class.  When initialized, wait for
    messages from a certain energy monitoring device, as described
    above.  (The particular device is given by the sensor_id argument
    to run() and is assumed to be represented in the database.) Insert
    data when it's received, and then wait for another message.
    '''

    def cleanup(self):
        '''
        Close database and socket connections in preparation for
        termination.
        '''
        info('Cleaning up: rolling back, disconnecting, disconnecting.')
        if not self.conn.closed:
            self.conn.rollback()
            self.conn.close()
        self.s.close()

    def handle_signal(self, signum, frame):
        '''
        If a SIGQUIT, SIGTERM, or SIGINT is received, shutdown cleanly.
        '''
        if signum == signal.SIGQUIT:
            info('Caught SIGQUIT.')
        elif signum == signal.SIGTERM:
            info('Caught SIGTERM.')
        elif signum == signal.SIGINT:
            info('Caught SIGINT.')
        # cleanup() will be called since it is registered with atexit
        sys.exit(0)

    def open_socket(self, ip):
        '''
        Open a socket to the device, looping until success.
        '''
        while True:
            try:
                self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                self.s.connect((ip, SENSOR_TCP_PORT))
                info('Socket connected to %s:%d.' % (ip, SENSOR_TCP_PORT))
                break
            except socket.error, detail:
                error(str(detail))
                error('Socket error.')
                error('Pausing, reopening socket.')
                time.sleep(ERROR_PAUSE)

    def run(self, sensor_id):
        '''
        Perform the main listen and insert loop of the program.
        (See file and class docstrings.)
        '''
        basicConfig(filename=(MON_LOG_FILE_TEMPL % sensor_id),
                    format=LOG_FORMAT, datefmt=LOG_DATEFMT, 
                    level=LOG_LEVEL)

        # Register exit and signal behaviors.
        atexit.register(self.cleanup)
        signal.signal(signal.SIGHUP, signal.SIG_IGN)
        signal.signal(signal.SIGINT, self.handle_signal)
        signal.signal(signal.SIGTERM, self.handle_signal)
        signal.signal(signal.SIGQUIT, self.handle_signal)

        # Connect to the PostgreSQL db, then query to collect basic 
        # information about the sensor to be monitored.
        try:
            self.conn = psycopg2.connect(PSQL_CONNSTR)
            cur = self.conn.cursor()
            info('Connected to SQL database.')
        except psycopg2.Error, detail:
            error(str(detail))
            error('Could not connect to SQL database.  Shutting down.')
            sys.exit(1)

        cur.execute('''SELECT sensors.name, sensors.ip, sensors.three_phase, 
                         sensors.factor, sensors.sensor_group_id, 
                         sensor_groups.name 
                       FROM sensors 
                       INNER JOIN sensor_groups 
                         ON sensors.sensor_group_id = sensor_groups.id 
                       WHERE sensors.id = %s;''', (sensor_id,))
        r = cur.fetchone()
        (name, ip, three_phase, factor, sg_id, sg_name) = r
        # If the sensor is three-phase, we want to add all three power
        # measurements to obtain the aggregate.  If the sensor is single
        # phase, only the first two measurements are meaningful---so 
        # we'll zero the third.
        phase_factor = (three_phase and 1 or 0)
    
        self.open_socket(ip)
    
        while True:
            data = ''
            debug('Listening for data.')
            # Loop until all 45 bytes of the message are collected.
            while len(data) < 45:
                data_recvd = self.s.recv(1024)
                if data_recvd == '':
                    error('Socket died.  Printing data, closing, reopening.')
                    error(hexlify(data) + '.')
                    self.s.close()
                    self.open_socket(ip)
                    data = ''
                else:
                    data += data_recvd
            debug('Data received.  (45 bytes)')
            if data[0:4] != 'RTSD': # 52 54 53 44 in hex
                error('Bad data.  Printing data, closing socket, reopening.')
                error(hexlify(data) + '.')
                self.s.close()
                self.open_socket(ip)
            else:
                # If the rudimentary validation succeeded, proceed to
                # interpret the data for processing and storage.
                debug('Data validated.')
                rindex = ord(data[4])
                # Lots of little uints
                awatthr = factor * ((ord(data[5]) << 8) | ord(data[6]))
                bwatthr = factor * ((ord(data[7]) << 8) | ord(data[8]))
                cwatthr = factor * ((ord(data[9]) << 8) | ord(data[10]))
                avarhr = factor * ((ord(data[11]) << 8) | ord(data[12]))
                bvarhr = factor * ((ord(data[13]) << 8) | ord(data[14]))
                cvarhr = factor * ((ord(data[15]) << 8) | ord(data[16]))
                avahr = factor * ((ord(data[17]) << 8) | ord(data[18]))
                bvahr = factor * ((ord(data[19]) << 8) | ord(data[20]))
                cvahr = factor * ((ord(data[21]) << 8) | ord(data[22]))
                airms = factor * ((ord(data[23]) << 16) | (ord(data[24]) << 8) 
                                                        | ord(data[25]))
                birms = factor * ((ord(data[26]) << 16) | (ord(data[27]) << 8) 
                                                        | ord(data[28]))
                cirms = factor * ((ord(data[29]) << 16) | (ord(data[30]) << 8) 
                                                        | ord(data[31]))
                avrms = ((ord(data[32]) << 16) | (ord(data[33]) << 8) 
                                               | ord(data[34]))
                bvrms = ((ord(data[35]) << 16) | (ord(data[36]) << 8) 
                                               | ord(data[37]))
                cvrms = ((ord(data[38]) << 16) | (ord(data[39]) << 8) 
                                               | ord(data[40]))
                freq = ((ord(data[41]) << 8) | ord(data[42])) >> 4
                # for tempc:  at Amb = 25C, register = DF = Offset
                tempc = 25 + (ord(data[43]) - int('df', 16)) * 3
    
                # Note: now() does not advance within a transaction, so
                # the rdngtimes in the queries below will be consistent.

                # Insert all data into the main db table.  Ask for the
                # timestamp, and that truncated to weeks/months, to ease
                # processing in the next steps.
                cur.execute('''INSERT INTO sensor_readings (rdngtime, 
                                 sensor_id, rindex, awatthr, bwatthr, cwatthr, 
                                 avarhr, bvarhr, cvarhr, avahr, bvahr, cvahr, 
                                 airms, birms, cirms, avrms, bvrms, cvrms, 
                                 freq, tempc)
                               VALUES (now(), %s, %s, %s, %s, %s, %s, %s, %s, 
                                 %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                               RETURNING CAST (now() AS 
                                 timestamp without time zone) AS rtnow,
                                 CAST (date_trunc('week', now()) AS 
                                 timestamp without time zone) AS rtnow_to_week,
                                 CAST (date_trunc('month', now()) AS 
                                 timestamp without time zone) AS rtnow_to_month
                                 ;''',
                            (sensor_id, rindex, awatthr, bwatthr, 
                             cwatthr * phase_factor, avarhr, bvarhr, cvarhr, 
                             avahr, bvahr, cvahr, airms, birms, cirms, avrms, 
                             bvrms, cvrms, freq, tempc))

                r = cur.fetchone()
                rdngtime = r[0]
                rdngtime_to_week = r[1]
                rdngtime_to_month = r[2]
                watts = awatthr + bwatthr + cwatthr * phase_factor

                # There are two average types we want to compute---one 
                # representing an average for the current week, and one 
                # representing an average for the current month.  (Hence 
                # the truncated timestamps.)  The loop below is just a 
                # shortcut to keep from duplicating the following lines.

                # We are computing these here because we can afford to; we
                # have 10 seconds until the next message.  On the other hand,
                # dozens of aggregations over thousands of rows each for a
                # single web request doesn't seem to please the machines.
                for (avg_type,
                     avg_type_name, rdngtime_to) in ((AVG_TYPE_WEEK, 'week',
                                                      rdngtime_to_week),
                                                     (AVG_TYPE_MONTH, 'month',
                                                      rdngtime_to_month)):
                    # Retrieve the previous average computed for this sensor
                    cur.execute('''SELECT rdngtime_first, 
                                     date_trunc('%s', rdngtime_first), 
                                     num_pts, watts 
                                   FROM power_averages 
                                   WHERE sensor_id = %%s AND avg_type = %%s 
                                   ORDER BY rdngtime_first DESC
                                   LIMIT 1;''' % avg_type_name, 
                                (sensor_id, avg_type))
    
                    [rdngtime_first, rdngtime_first_to, 
                     num_pts, prev_watts] = cur.fetchone()
    
                    # If we're still in the week/month of the previous average,
                    # augment it with the data point we just collected.
                    # Otherwise, insert a new average for this new time period.
                    if rdngtime_to == rdngtime_first_to:
                        cur.execute('''UPDATE power_averages 
                                       SET rdngtime_last = %s, num_pts = %s, 
                                         watts = %s 
                                       WHERE sensor_id = %s AND avg_type = %s
                                         AND rdngtime_first = %s''',
                                    (rdngtime, num_pts + 1, 
                                     (prev_watts*num_pts + watts)/(num_pts+1),
                                     sensor_id, avg_type, rdngtime_first))
                    else:
                        cur.execute('''INSERT INTO power_averages 
                                         (rdngtime_first, rdngtime_last, 
                                         sensor_id, avg_type, num_pts, watts)
                                       VALUES (%s, %s, %s, %s, 1, %s);''',
                                    (rdngtime, rdngtime, sensor_id, avg_type,
                                     watts))
                self.conn.commit()
                debug('Data processed.')
    
        self.cleanup()
        info('Past main loop.  Exiting.')
        sys.exit(0)


if __name__ == '__main__':
    if len(sys.argv) == 3:
        sensor_id = int(sys.argv[1])
        daemon = EnergyMonDaemon(MON_PID_FILE_TEMPL % sensor_id, 
                                 args=(sensor_id,), 
                                 stdout=(MON_LOG_FILE_TEMPL % sensor_id),
                                 stderr=(MON_LOG_FILE_TEMPL % sensor_id))
        if sys.argv[2] == 'start':
            daemon.start()
        elif sys.argv[2] == 'stop':
            daemon.stop()
        elif sys.argv[2] == 'restart':
            daemon.restart()
        else:
            print MON_USAGE_TEMPL % sys.argv[0]
            sys.exit(1)
    else:
        print MON_USAGE_TEMPL % sys.argv[0]
        sys.exit(1)
