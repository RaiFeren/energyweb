#!/usr/bin/env python


import sys
sys.path.append('/var/local/energy/lib')
import socket, psycopg2, datetime, atexit, signal, time
from daemon import Daemon
from logging import error, info, debug, basicConfig
from fake_rhizome_profiles import FAKE_RHIZOME_PROFILES
from SocketServer import TCPServer, BaseRequestHandler
from random import random, randint
from binascii import unhexlify
from energyconfig import *


class FakeRhizomeHandler(BaseRequestHandler):
    def handle(self):
        info('%s:%d connected.' % self.client_address)

        reading_num = 0
        reading = self.profile[reading_num]

        while True:
            chars_sent = 0
            while chars_sent < 45:
                chars_to_send = randint(1, 45 - chars_sent)
                r = reading[chars_sent:(chars_sent + chars_to_send)]
                self.request.send(r)
                chars_sent += chars_to_send
                debug('Reading %d: data sent.  (%d bytes)' 
                      % (reading_num, chars_to_send))

            reading_num += 1
            if reading_num == len(self.profile):
                reading_num = 0
            reading = self.profile[reading_num]

            time.sleep(10 + (random() - 0.5) * FAKER_SLEEP_VARIATION)

        self.request.close()
        info('%s:%d closed.' % self.client_address)


class FakeRhizomeDaemon(Daemon):
    '''
    Subclass of a daemonizing class.  When initialized, wait for
    messages from a certain energy monitoring device, as described
    above.  (The particular device is given by the sensor_id argument
    to run() and is assumed to be represented in the database.) Insert
    data when it's received, and then wait for another message.
    '''

    def cleanup(self):
        '''
        Close database and socket connections in preparation for
        termination.
        '''
        info('Cleaning up: rolling back, disconnecting, disconnecting.')
        if not self.conn.closed:
            self.conn.rollback()
            self.conn.close()
        self.s.shutdown()

    def handle_signal(self, signum, frame):
        '''
        If a SIGQUIT, SIGTERM, or SIGINT is received, shutdown cleanly.
        '''
        if signum == signal.SIGQUIT:
            info('Caught SIGQUIT.')
        elif signum == signal.SIGTERM:
            info('Caught SIGTERM.')
        elif signum == signal.SIGINT:
            info('Caught SIGINT.')
        # cleanup() will be called since it is registered with atexit
        sys.exit(0)

    def run(self, sensor_id):
        '''
        Perform the main listen and insert loop of the program.
        (See file and class docstrings.)
        '''
        basicConfig(filename=(FAKER_LOG_FILE_TEMPL % sensor_id),
                    format=LOG_FORMAT, datefmt=LOG_DATEFMT, 
                    level=LOG_LEVEL)

        # Register exit and signal behaviors.
        atexit.register(self.cleanup)
        signal.signal(signal.SIGHUP, signal.SIG_IGN)
        signal.signal(signal.SIGINT, self.handle_signal)
        signal.signal(signal.SIGTERM, self.handle_signal)
        signal.signal(signal.SIGQUIT, self.handle_signal)

        # Connect to the PostgreSQL db, then query to collect basic 
        # information about the sensor to be monitored.
        try:
            self.conn = psycopg2.connect(PSQL_CONNSTR)
            cur = self.conn.cursor()
            info('Connected to SQL database.')
        except psycopg2.Error, detail:
            error(str(detail))
            error('Could not connect to SQL database.  Shutting down.')
            sys.exit(1)

        cur.execute('''SELECT sensors.name, sensors.ip, sensors.port, 
                         sensor_groups.name
                       FROM sensors
                       INNER JOIN sensor_groups 
                         ON sensors.sensor_group_id = sensor_groups.id 
                       WHERE sensors.id = %s;''', (sensor_id,))
        (name, ip, port, group_name) = cur.fetchone()
        addr = '%s:%d' % (ip, port)
        if name == '':
            desc = group_name
        else:
            desc = '%s %s' % (group_name, name)
    
        FakeRhizomeHandler.profile = [unhexlify(s) for s in 
                                      FAKE_RHIZOME_PROFILES[sensor_id]]
        self.s = TCPServer((ip, port), FakeRhizomeHandler)
        print 'Serving for sensor %d (%s, %s).' % (sensor_id, desc, addr)
        self.s.serve_forever()


if __name__ == '__main__':
    if len(sys.argv) == 3:
        try:
            sensor_id = int(sys.argv[1])
        except ValueError:
            print FAKER_USAGE_TEMPL % sys.argv[0]
            sys.exit(1)

        daemon = FakeRhizomeDaemon(FAKER_PID_FILE_TEMPL % sensor_id, 
                                   args=(sensor_id,), 
                                   stdout=(FAKER_LOG_FILE_TEMPL % sensor_id),
                                   stderr=(FAKER_LOG_FILE_TEMPL % sensor_id))
        if sys.argv[2] == 'start':
            daemon.start()
        elif sys.argv[2] == 'stop':
            daemon.stop()
        elif sys.argv[2] == 'restart':
            daemon.restart()
        else:
            print FAKER_USAGE_TEMPL % sys.argv[0]
            sys.exit(1)
    else:
        print FAKER_USAGE_TEMPL % sys.argv[0]
        sys.exit(1)


################################################################


        cur.execute('''SELECT sensors.name, sensors.ip, sensors.port,
                         sensors.three_phase, sensors.factor, 
                         sensors.sensor_group_id, sensor_groups.name 
                       FROM sensors 
                       INNER JOIN sensor_groups 
                         ON sensors.sensor_group_id = sensor_groups.id 
                       WHERE sensors.id = %s;''', (sensor_id,))
        r = cur.fetchone()
        (name, ip, port, three_phase, factor, sg_id, sg_name) = r
        # If the sensor is three-phase, we want to add all three power
        # measurements to obtain the aggregate.  If the sensor is single
        # phase, only the first two measurements are meaningful---so 
        # we'll zero the third.
        phase_factor = (three_phase and 1 or 0)
    
        self.open_socket(ip, port)
    
        while True:
            data = ''
            debug('Listening for data.')
            # Loop until all 45 bytes of the message are collected.
            while len(data) < 45:
                data_recvd = self.s.recv(1024)
                if data_recvd == '':
                    error('Socket died.  Printing data, closing, reopening.')
                    error(hexlify(data) + '.')
                    self.s.close()
                    self.open_socket(ip, port)
                    data = ''
                else:
                    data += data_recvd
            debug('Data received.  (45 bytes)')
            if data[0:4] != 'RTSD': # 52 54 53 44 in hex
                error('Bad data.  Printing data, closing socket, reopening.')
                error(hexlify(data) + '.')
                self.s.close()
                self.open_socket(ip, port)
            else:
                # If the rudimentary validation succeeded, proceed to
                # interpret the data for processing and storage.
                debug('Data validated.')
                rindex = ord(data[4])
                # Lots of little uints
                awatthr = factor * ((ord(data[5]) << 8) | ord(data[6]))
                bwatthr = factor * ((ord(data[7]) << 8) | ord(data[8]))
                cwatthr = factor * ((ord(data[9]) << 8) | ord(data[10]))
                avarhr = factor * ((ord(data[11]) << 8) | ord(data[12]))
                bvarhr = factor * ((ord(data[13]) << 8) | ord(data[14]))
                cvarhr = factor * ((ord(data[15]) << 8) | ord(data[16]))
                avahr = factor * ((ord(data[17]) << 8) | ord(data[18]))
                bvahr = factor * ((ord(data[19]) << 8) | ord(data[20]))
                cvahr = factor * ((ord(data[21]) << 8) | ord(data[22]))
                airms = factor * ((ord(data[23]) << 16) | (ord(data[24]) << 8) 
                                                        | ord(data[25]))
                birms = factor * ((ord(data[26]) << 16) | (ord(data[27]) << 8) 
                                                        | ord(data[28]))
                cirms = factor * ((ord(data[29]) << 16) | (ord(data[30]) << 8) 
                                                        | ord(data[31]))
                avrms = ((ord(data[32]) << 16) | (ord(data[33]) << 8) 
                                               | ord(data[34]))
                bvrms = ((ord(data[35]) << 16) | (ord(data[36]) << 8) 
                                               | ord(data[37]))
                cvrms = ((ord(data[38]) << 16) | (ord(data[39]) << 8) 
                                               | ord(data[40]))
                freq = ((ord(data[41]) << 8) | ord(data[42])) >> 4
                # for tempc:  at Amb = 25C, register = DF = Offset
                tempc = 25 + (ord(data[43]) - int('df', 16)) * 3
    
                # Note: now() does not advance within a transaction, so
                # the rdngtimes in the queries below will be consistent.

                # Insert all data into the main db table.  Ask for the
                # timestamp, and that truncated to weeks/months, to ease
                # processing in the next steps.
                cur.execute('''INSERT INTO sensor_readings (rdngtime, 
                                 sensor_id, rindex, awatthr, bwatthr, cwatthr, 
                                 avarhr, bvarhr, cvarhr, avahr, bvahr, cvahr, 
                                 airms, birms, cirms, avrms, bvrms, cvrms, 
                                 freq, tempc)
                               VALUES (now(), %s, %s, %s, %s, %s, %s, %s, %s, 
                                 %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                               RETURNING CAST (now() AS 
                                 timestamp without time zone) AS rtnow,
                                 CAST (date_trunc('week', now()) AS 
                                 timestamp without time zone) AS rtnow_to_week,
                                 CAST (date_trunc('month', now()) AS 
                                 timestamp without time zone) AS rtnow_to_month,
                                 CAST (date_trunc('minute', now()) AS 
                                 timestamp without time zone) 
                                   AS rtnow_to_minute,
                                 CAST (date_trunc('hour', now()) AS 
                                 timestamp without time zone) AS rtnow_to_hour
                                 ;''',
                            (sensor_id, rindex, awatthr, bwatthr, 
                             cwatthr * phase_factor, avarhr, bvarhr, cvarhr, 
                             avahr, bvahr, cvahr, airms, birms, cirms, avrms, 
                             bvrms, cvrms, freq, tempc))

                r = cur.fetchone()
                rdngtime = r[0]
                rdngtime_to_week = r[1]
                rdngtime_to_month = r[2]
                rdngtime_to_minute = r[3]
                rdngtime_to_hour = r[4]
                watts = awatthr + bwatthr + cwatthr * phase_factor

                # There are two average types we want to compute---one 
                # representing an average for the current week, and one 
                # representing an average for the current month.  (Hence 
                # the truncated timestamps.)  The loop below is just a 
                # shortcut to keep from duplicating the following lines.

                # We are computing these here because we can afford to; we
                # have 10 seconds until the next message.  On the other hand,
                # dozens of aggregations over thousands of rows each for a
                # single web request doesn't seem to please the machines.
                for (avg_type,
                     avg_type_name, rdngtime_to) in ((AVG_TYPE_WEEK, 'week',
                                                      rdngtime_to_week),
                                                     (AVG_TYPE_MONTH, 'month',
                                                      rdngtime_to_month)):
                    # Retrieve the previous average computed for this sensor
                    cur.execute('''SELECT rdngtime_first, 
                                     date_trunc('%s', rdngtime_first), 
                                     num_pts, watts 
                                   FROM power_averages 
                                   WHERE sensor_id = %%s AND avg_type = %%s 
                                   ORDER BY rdngtime_first DESC
                                   LIMIT 1;''' % avg_type_name, 
                                (sensor_id, avg_type))
    
                    r = cur.fetchone()
    
                    # If we're still in the week/month of the previous average,
                    # augment it with the data point we just collected.
                    # Otherwise, insert a new average for this new time period.
                    if r is not None and rdngtime_to == r[1]:
                        [rdngtime_first, rdngtime_first_to, 
                         num_pts, prev_watts] = r
                        cur.execute('''UPDATE power_averages 
                                       SET rdngtime_last = %s, num_pts = %s, 
                                         watts = %s 
                                       WHERE sensor_id = %s AND avg_type = %s
                                         AND rdngtime_first = %s''',
                                    (rdngtime, num_pts + 1, 
                                     (prev_watts*num_pts + watts)/(num_pts+1),
                                     sensor_id, avg_type, rdngtime_first))
                    else:
                        cur.execute('''INSERT INTO power_averages 
                                         (rdngtime_first, rdngtime_last, 
                                         sensor_id, avg_type, num_pts, watts)
                                       VALUES (%s, %s, %s, %s, 1, %s);''',
                                    (rdngtime, rdngtime, sensor_id, avg_type,
                                     watts))
                self.conn.commit()
                debug('Data processed.')
    
        self.cleanup()
        info('Past main loop.  Exiting.')
        sys.exit(0)
